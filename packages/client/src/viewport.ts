/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  BooleanResponse,
  CountKind,
  CountRequest,
  CountResponse,
  CreateViewportRequest,
  ModifyViewportRequest,
  ObjectId,
  ViewportDataRequest,
  ViewportDataResponse,
} from './omega_edit_pb'
import { getLogger } from './logger'
import { getClient } from './client'

let autoFixViewportDataLength_ = false

/**
 * Set whether to automatically fix viewport data length
 * @param shouldAutoFix true if the client should automatically fix viewport data length, false otherwise
 */
export function setAutoFixViewportDataLength(shouldAutoFix: boolean): void {
  getLogger().debug({
    fn: 'setAutoFixViewportDataLength',
    shouldAutoFix: shouldAutoFix,
  })
  autoFixViewportDataLength_ = shouldAutoFix
}

/**
 * Create a new viewport in a session
 * @param desired_viewport_id if defined, the viewport ID to assign to this viewport, if undefined a unique viewport ID
 * will be generated by the server
 * @param session_id session to create the viewport in
 * @param offset byte-offset start of the viewport
 * @param capacity capacity of the viewport in bytes
 * @param is_floating false if the viewport is to remain fixed at the given offset, true if the viewport is expected to
 * "float" as bytes are inserted or deleted before the start of this viewport
 * @return created viewport's ID, on success
 */
export async function createViewport(
  desired_viewport_id: string | undefined,
  session_id: string,
  offset: number,
  capacity: number,
  is_floating: boolean = false
): Promise<ViewportDataResponse> {
  const log = getLogger()
  let request = new CreateViewportRequest()
    .setSessionId(session_id)
    .setOffset(offset)
    .setCapacity(capacity)
    .setIsFloating(is_floating)
  if (desired_viewport_id !== undefined && desired_viewport_id.length > 0) {
    request.setViewportIdDesired(desired_viewport_id)
  }
  log.debug({ fn: 'createViewport', rqst: request.toObject() })
  const client = await getClient()
  return new Promise<ViewportDataResponse>((resolve, reject) => {
    client.createViewport(request, (err, r: ViewportDataResponse) => {
      if (err) {
        log.error({
          fn: 'createViewport',
          err: {
            msg: err.message,
            details: err.details,
            code: err.code,
            stack: err.stack,
          },
        })
        return reject(`createViewport error: ${err.message}`)
      }
      log.debug({ fn: 'createViewport', resp: r.toObject() })
      return resolve(r)
    })
  })
}

/**
 * Modify a given viewport
 * @param viewport_id viewport to modify
 * @param offset new byte-offset start of the viewport
 * @param capacity new capacity of the viewport in bytes
 * @param is_floating false if the viewport is to remain fixed at the given offset, true if the viewport is expected to
 * "float" as bytes are inserted or deleted before the start of this viewport
 * @return ViewportDataResponse, on success
 */
export async function modifyViewport(
  viewport_id: string,
  offset: number,
  capacity: number,
  is_floating: boolean = false
): Promise<ViewportDataResponse> {
  const log = getLogger()
  const request = new ModifyViewportRequest()
    .setViewportId(viewport_id)
    .setOffset(offset)
    .setCapacity(capacity)
    .setIsFloating(is_floating)
  log.debug({ fn: 'modifyViewport', rqst: request.toObject() })
  const client = await getClient()
  return new Promise<ViewportDataResponse>((resolve, reject) => {
    client.modifyViewport(request, (err, r: ViewportDataResponse) => {
      if (err) {
        log.error({
          fn: 'modifyViewport',
          err: {
            msg: err.message,
            details: err.details,
            code: err.code,
            stack: err.stack,
          },
        })
        return reject(`modifyViewport error: ${err.message}`)
      }
      log.debug({ fn: 'modifyViewport', resp: r.toObject() })
      return resolve(r)
    })
  })
}

/**
 * Destroy a given viewport
 * @param viewport_id viewport to destroy
 * @return destroyed viewport's ID, on success
 */
export async function destroyViewport(viewport_id: string): Promise<string> {
  const log = getLogger()
  const request = new ObjectId().setId(viewport_id)
  log.debug({ fn: 'destroyViewport', rqst: request.toObject() })
  const client = await getClient()
  return new Promise<string>((resolve, reject) => {
    client.destroyViewport(request, (err, r) => {
      if (err) {
        log.error({
          fn: 'destroyViewport',
          err: {
            msg: err.message,
            details: err.details,
            code: err.code,
            stack: err.stack,
          },
        })
        return reject(`destroyViewport error: ${err.message}`)
      }
      log.debug({ fn: 'destroyViewport', resp: r.toObject() })
      return resolve(r.getId())
    })
  })
}

/**
 * Given a session, return the number of viewports in that session
 * @param sesssion_id session to get the number of viewports in
 * @return number of viewports in the given session, on success
 */
export async function getViewportCount(sesssion_id: string): Promise<number> {
  const log = getLogger()
  const request = new CountRequest()
    .setSessionId(sesssion_id)
    .setKindList([CountKind.COUNT_VIEWPORTS])
  log.debug({ fn: 'getViewportCount', rqst: request.toObject() })
  const client = await getClient()
  return new Promise<number>((resolve, reject) => {
    client.getCount(request, (err, r: CountResponse) => {
      if (err) {
        log.error({
          fn: 'getViewportCount',
          err: {
            msg: err.message,
            details: err.details,
            code: err.code,
            stack: err.stack,
          },
        })
        return reject(`getViewportCount error: ${err.message}`)
      }
      log.debug({ fn: 'getViewportCount', resp: r.toObject() })
      return resolve(r.getCountsList()[0].getCount())
    })
  })
}

/**
 * Given a viewport ID, return the data in the viewport
 * @param viewport_id viewport to get the data from
 * @return ViewportDataResponse with the data and where it is in the session, on success
 * @remarks viewport length can be less than the viewport capacity
 */
export async function getViewportData(
  viewport_id: string
): Promise<ViewportDataResponse> {
  const log = getLogger()
  const request = new ViewportDataRequest().setViewportId(viewport_id)
  log.debug({ fn: 'getViewportData', rqst: request.toObject() })
  const client = await getClient()
  return new Promise<ViewportDataResponse>((resolve, reject) => {
    client.getViewportData(request, (err, r: ViewportDataResponse) => {
      if (err) {
        log.error({
          fn: 'getViewportData',
          err: {
            msg: err.message,
            details: err.details,
            code: err.code,
            stack: err.stack,
          },
        })
        return reject(`getViewportData error: ${err.message}`)
      }

      log.debug({ fn: 'getViewportData', resp: r.toObject() })

      // TODO: remove this once the server issue is discovered and fixed
      if (autoFixViewportDataLength_) {
        const dataLength = r.getData().length
        const expectedLength = r.getLength()
        if (dataLength !== expectedLength) {
          if (dataLength > expectedLength) {
            log.error({
              fn: 'getViewportData',
              err: {
                msg: `AUTO FIX: truncating data length to ${expectedLength}`,
              },
            })
            r.setData(r.getData().slice(0, expectedLength))
          } else {
            const errorMsg = 'data has unexpected length'
            log.error({
              fn: 'getViewportData',
              err: {
                msg: errorMsg,
                datalength: dataLength,
                length: expectedLength,
              },
            })
            return reject(errorMsg)
          }
        }
      }

      return resolve(r)
    })
  })
}

/**
 * Given a viewport ID, returns true if the viewport has changes and false otherwise
 * @param viewport_id viewport to check for changes
 * @return true if the viewport has changes and false otherwise
 */
export async function viewportHasChanges(
  viewport_id: string
): Promise<boolean> {
  const log = getLogger()
  const request = new ObjectId().setId(viewport_id)
  log.debug({ fn: 'viewportHasChanges', rqst: request.toObject() })
  const client = await getClient()
  return new Promise<boolean>((resolve, reject) => {
    client.viewportHasChanges(request, (err, r: BooleanResponse) => {
      if (err) {
        log.error({
          fn: 'viewportHasChanges',
          err: {
            msg: err.message,
            details: err.details,
            code: err.code,
            stack: err.stack,
          },
        })
        return reject(`viewportHasChanges error: ${err.message}`)
      }
      log.debug({ fn: 'viewportHasChanges', resp: r.toObject() })
      return resolve(r.getResponse())
    })
  })
}

/**
 * Pause viewport events being triggered on this session
 * @param session_id session to pause viewport events on
 * @return session ID that has had its viewport events paused, on success
 */
export async function pauseViewportEvents(session_id: string): Promise<string> {
  const log = getLogger()
  const request = new ObjectId().setId(session_id)
  log.debug({ fn: 'pauseViewportEvents', rqst: request.toObject() })
  const client = await getClient()
  return new Promise<string>((resolve, reject) => {
    client.pauseViewportEvents(request, (err, r: ObjectId) => {
      if (err) {
        log.error({
          fn: 'pauseViewportEvents',
          err: {
            msg: err.message,
            details: err.details,
            code: err.code,
            stack: err.stack,
          },
        })
        return reject(`pauseViewportEvents error: ${err.message}`)
      }
      log.debug({ fn: 'pauseViewportEvents', resp: r.toObject() })
      return resolve(r.getId())
    })
  })
}

/**
 * Resume events on viewports in the given session
 * @param session_id to resume viewport events on
 * @return session ID that has had its viewport events resumed, on success
 */
export async function resumeViewportEvents(
  session_id: string
): Promise<string> {
  const log = getLogger()
  const request = new ObjectId().setId(session_id)
  log.debug({ fn: 'resumeViewportEvents', rqst: request.toObject() })
  const client = await getClient()
  return new Promise<string>((resolve, reject) => {
    client.resumeViewportEvents(request, (err, r: ObjectId) => {
      if (err) {
        log.error({
          fn: 'resumeViewportEvents',
          err: {
            msg: err.message,
            details: err.details,
            code: err.code,
            stack: err.stack,
          },
        })
        return reject(`resumeViewportEvents error: ${err.message}`)
      }
      log.debug({ fn: 'resumeViewportEvents', resp: r.toObject() })
      return resolve(r.getId())
    })
  })
}

/**
 * Unsubscribe from events for the given viewport
 * @param viewport_id viewport to unsubscribe from events
 * @return viewport ID that has been unsubscribed from events, on success
 */
export async function unsubscribeViewport(
  viewport_id: string
): Promise<string> {
  const log = getLogger()
  const request = new ObjectId().setId(viewport_id)
  log.debug({ fn: 'unsubscribeViewport', rqst: request.toObject() })
  const client = await getClient()
  return new Promise<string>((resolve, reject) => {
    client
      .unsubscribeToViewportEvents(request, (err, r: ObjectId) => {
        if (err) {
          log.error({
            fn: 'unsubscribeViewport',
            err: {
              msg: err.message,
              details: err.details,
              code: err.code,
              stack: err.stack,
            },
          })
          return reject(`unsubscribeViewport error: ${err.message}`)
        }
        log.debug({ fn: 'unsubscribeViewport', resp: r.toObject() })
        return resolve(r.getId())
      })
      .on('error', (err) => {
        // Call cancelled thrown when server is shutdown
        if (!err.message.includes('Call cancelled')) {
          throw err
        }
      })
  })
}
